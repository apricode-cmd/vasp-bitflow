---
description: "Security –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"
alwaysApply: true
---

# Security Standards - Apricode Exchange

## üîê –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–ê–í–ò–õ–ê –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò

### ‚ö†Ô∏è –ù–ò–ö–û–ì–î–ê –Ω–µ –¥–µ–ª–∞–π:

1. ‚ùå **–ù–ï —Ö—Ä–∞–Ω–∏ —Å–µ–∫—Ä–µ—Ç—ã –≤ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–º –∫–æ–¥–µ**
2. ‚ùå **–ù–ï –∫–æ–º–º–∏—Ç—å .env —Ñ–∞–π–ª—ã –≤ Git**
3. ‚ùå **–ù–ï –ª–æ–≥–∏—Ä—É–π –ø–∞—Ä–æ–ª–∏ –∏–ª–∏ —Ç–æ–∫–µ–Ω—ã**
4. ‚ùå **–ù–ï –¥–æ–≤–µ—Ä—è–π –≤—Ö–æ–¥–Ω—ã–º –¥–∞–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è**
5. ‚ùå **–ù–ï –≤–æ–∑–≤—Ä–∞—â–∞–π –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –æ—à–∏–±–æ–∫ –≤ production**
6. ‚ùå **–ù–ï –∏—Å–ø–æ–ª—å–∑—É–π eval() –∏–ª–∏ Function()**
7. ‚ùå **–ù–ï –¥–µ–ª–∞–π SQL –∑–∞–ø—Ä–æ—Å—ã –Ω–∞–ø—Ä—è–º—É—é (–∏—Å–ø–æ–ª—å–∑—É–π Prisma)**
8. ‚ùå **–ù–ï –æ—Ç–∫–ª—é—á–∞–π CSRF –∑–∞—â–∏—Ç—É**

## üîë Environment Variables

### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ .env

```bash
# .env.local (–ù–ï –∫–æ–º–º–∏—Ç–∏—Ç—å!)

# Database
DATABASE_URL="postgresql://user:password@localhost:5432/apricode"

# NextAuth
NEXTAUTH_SECRET="generate-strong-secret-here"
NEXTAUTH_URL="http://localhost:3000"

# KYCAID
KYCAID_API_KEY="your-kycaid-api-key"
KYCAID_FORM_ID="your-form-id"
KYCAID_WEBHOOK_SECRET="your-webhook-secret"

# CoinGecko
COINGECKO_API_URL="https://api.coingecko.com/api/v3"

# Email
RESEND_API_KEY="re_xxxxxxxxxxxx"
EMAIL_FROM="noreply@apricode.io"

# Admin
ADMIN_EMAIL="admin@apricode.io"
ADMIN_PASSWORD="SecurePassword123!"
```

### –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

```typescript
// ‚úÖ Server-only
// src/lib/config.ts

if (typeof window !== 'undefined') {
  throw new Error('This file should only run on the server');
}

export const config = {
  database: {
    url: process.env.DATABASE_URL!
  },
  kycaid: {
    apiKey: process.env.KYCAID_API_KEY!,
    formId: process.env.KYCAID_FORM_ID!,
    webhookSecret: process.env.KYCAID_WEBHOOK_SECRET!
  },
  email: {
    apiKey: process.env.RESEND_API_KEY!,
    from: process.env.EMAIL_FROM!
  }
};

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π —Ç–∞–∫
import { config } from '@/lib/config';
const apiKey = config.kycaid.apiKey;

// ‚ùå –ù–ï —Ç–∞–∫
const apiKey = process.env.KYCAID_API_KEY; // –í –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–º –∫–æ–¥–µ!
```

### Environment validation

```typescript
// src/lib/env.ts

import { z } from 'zod';

const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NEXTAUTH_SECRET: z.string().min(32),
  NEXTAUTH_URL: z.string().url(),
  KYCAID_API_KEY: z.string().min(10),
  KYCAID_FORM_ID: z.string(),
  KYCAID_WEBHOOK_SECRET: z.string().min(20),
  RESEND_API_KEY: z.string().startsWith('re_'),
  EMAIL_FROM: z.string().email(),
  NODE_ENV: z.enum(['development', 'production', 'test'])
});

// ‚úÖ –í–∞–ª–∏–¥–∏—Ä—É–π –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
try {
  envSchema.parse(process.env);
} catch (error) {
  console.error('‚ùå Invalid environment variables:', error);
  process.exit(1);
}
```

## üîí Authentication

### Password Hashing

```typescript
import bcrypt from 'bcryptjs';

// ‚úÖ –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è (–º–∏–Ω–∏–º—É–º 10 rounds)
const SALT_ROUNDS = 10;

async function hashPassword(password: string): Promise<string> {
  return await bcrypt.hash(password, SALT_ROUNDS);
}

// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è
async function verifyPassword(
  password: string, 
  hashedPassword: string
): Promise<boolean> {
  return await bcrypt.compare(password, hashedPassword);
}

// ‚ùå –ù–ò–ö–û–ì–î–ê –Ω–µ —Ö—Ä–∞–Ω–∏ –ø–∞—Ä–æ–ª–∏ –≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –≤–∏–¥–µ
await prisma.user.create({
  data: {
    email,
    password: password // ‚ùå –ù–ï–¢!
  }
});

// ‚úÖ –í–°–ï–ì–î–ê —Ö–µ—à–∏—Ä—É–π
await prisma.user.create({
  data: {
    email,
    password: await hashPassword(password) // ‚úÖ –î–ê!
  }
});
```

### Password Requirements

```typescript
import { z } from 'zod';

// ‚úÖ –°—Ç—Ä–æ–≥–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –ø–∞—Ä–æ–ª—é
const passwordSchema = z.string()
  .min(8, 'Password must be at least 8 characters')
  .regex(/[A-Z]/, 'Password must contain uppercase letter')
  .regex(/[a-z]/, 'Password must contain lowercase letter')
  .regex(/[0-9]/, 'Password must contain number')
  .regex(/[^A-Za-z0-9]/, 'Password must contain special character');

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
try {
  passwordSchema.parse(userPassword);
} catch (error) {
  // –ü–æ–∫–∞–∂–∏ –æ—à–∏–±–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
}
```

### Session Management

```typescript
// src/lib/auth.ts

import { NextAuthOptions } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import { prisma } from '@/lib/prisma';
import bcrypt from 'bcryptjs';

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('Missing credentials');
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
          include: { profile: true }
        });

        if (!user) {
          // ‚úÖ –ù–ï —Ä–∞—Å–∫—Ä—ã–≤–∞–π, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ email
          throw new Error('Invalid credentials');
        }

        const isValid = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isValid) {
          throw new Error('Invalid credentials');
        }

        // ‚ùå –ù–ï –≤–æ–∑–≤—Ä–∞—â–∞–π –ø–∞—Ä–æ–ª—å!
        const { password, ...userWithoutPassword } = user;

        return {
          id: user.id,
          email: user.email,
          role: user.role,
          name: user.profile?.firstName
        };
      }
    })
  ],
  
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
        session.user.role = token.role as string;
      }
      return session;
    }
  },
  
  pages: {
    signIn: '/login',
    error: '/login'
  },
  
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 –¥–Ω–µ–π
  },
  
  // ‚úÖ –°–∏–ª—å–Ω—ã–π —Å–µ–∫—Ä–µ—Ç
  secret: process.env.NEXTAUTH_SECRET
};
```

## üõ°Ô∏è Input Validation

### –í–°–ï–ì–î–ê –≤–∞–ª–∏–¥–∏—Ä—É–π –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ

```typescript
import { z } from 'zod';

// ‚úÖ –û–ø—Ä–µ–¥–µ–ª–∏ —Å—Ö–µ–º—É
const createOrderSchema = z.object({
  currency: z.enum(['BTC', 'ETH', 'USDT', 'SOL']),
  amount: z.number()
    .positive('Amount must be positive')
    .max(1000000, 'Amount too large'),
  walletAddress: z.string()
    .min(26, 'Invalid wallet address')
    .max(62, 'Invalid wallet address')
    .regex(/^[a-zA-Z0-9]+$/, 'Invalid characters in wallet address'),
  fiatCurrency: z.enum(['EUR', 'PLN'])
});

// ‚úÖ –í API route
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    const validatedData = createOrderSchema.parse(body);
    
    // –ò—Å–ø–æ–ª—å–∑—É–π validatedData (–Ω–µ body!)
    await createOrder(validatedData);
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
  }
}
```

### Sanitization

```typescript
// ‚úÖ –û—á–∏—Å—Ç–∫–∞ —Å—Ç—Ä–æ–∫
function sanitizeString(input: string): string {
  return input
    .trim()
    .replace(/[<>]/g, '') // –£–¥–∞–ª–∏ HTML —Ç–µ–≥–∏
    .slice(0, 1000); // –û–≥—Ä–∞–Ω–∏—á—å –¥–ª–∏–Ω—É
}

// ‚úÖ Email –≤–∞–ª–∏–¥–∞—Ü–∏—è
const emailSchema = z.string()
  .email('Invalid email')
  .toLowerCase()
  .transform(email => email.trim());

// ‚úÖ URL –≤–∞–ª–∏–¥–∞—Ü–∏—è
const urlSchema = z.string()
  .url('Invalid URL')
  .refine(url => {
    const parsed = new URL(url);
    return ['http:', 'https:'].includes(parsed.protocol);
  }, 'Only HTTP/HTTPS allowed');
```

## üîì Authorization

### Route Protection

```typescript
// src/middleware.ts

import { withAuth } from 'next-auth/middleware';

export default withAuth({
  callbacks: {
    authorized: ({ req, token }) => {
      const path = req.nextUrl.pathname;
      
      // Public routes
      if (path === '/' || path.startsWith('/login') || path.startsWith('/register')) {
        return true;
      }
      
      // Must be authenticated
      if (!token) {
        return false;
      }
      
      // Admin routes
      if (path.startsWith('/admin')) {
        return token.role === 'ADMIN';
      }
      
      // Client routes
      return true;
    }
  },
  pages: {
    signIn: '/login'
  }
});

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/buy/:path*',
    '/orders/:path*',
    '/kyc/:path*',
    '/profile/:path*',
    '/admin/:path*'
  ]
};
```

### API Authorization

```typescript
// src/lib/auth-utils.ts

import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { NextResponse } from 'next/server';

// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
export async function requireAuth() {
  const session = await getServerSession(authOptions);
  
  if (!session?.user) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }
  
  return session;
}

// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–æ–ª–∏
export async function requireRole(role: 'CLIENT' | 'ADMIN') {
  const session = await getServerSession(authOptions);
  
  if (!session?.user) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }
  
  if (session.user.role !== role) {
    return NextResponse.json(
      { error: 'Forbidden' },
      { status: 403 }
    );
  }
  
  return session;
}

// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–º
export async function requireResourceOwnership(
  resourceUserId: string
) {
  const session = await getServerSession(authOptions);
  
  if (!session?.user) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }
  
  // Admin –º–æ–∂–µ—Ç –≤—Å—ë
  if (session.user.role === 'ADMIN') {
    return session;
  }
  
  // –û–±—ã—á–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ —Ä–µ—Å—É—Ä—Å—ã
  if (session.user.id !== resourceUserId) {
    return NextResponse.json(
      { error: 'Forbidden' },
      { status: 403 }
    );
  }
  
  return session;
}
```

## üîó API Security

### Webhook Signature Verification

```typescript
import crypto from 'crypto';

// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏ KYCAID webhook
export function verifyKycaidSignature(
  body: string,
  signature: string,
  secret: string
): boolean {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(body)
    .digest('hex');
    
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ webhook
export async function POST(request: NextRequest) {
  const signature = request.headers.get('x-signature');
  const body = await request.text();
  
  if (!signature) {
    return NextResponse.json(
      { error: 'Missing signature' },
      { status: 401 }
    );
  }
  
  const isValid = verifyKycaidSignature(
    body,
    signature,
    process.env.KYCAID_WEBHOOK_SECRET!
  );
  
  if (!isValid) {
    return NextResponse.json(
      { error: 'Invalid signature' },
      { status: 401 }
    );
  }
  
  // –û–±—Ä–∞–±–æ—Ç–∞–π webhook
}
```

### Rate Limiting (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–ª—è production)

```typescript
// src/lib/rate-limit.ts

import { LRUCache } from 'lru-cache';

type RateLimitOptions = {
  uniqueTokenPerInterval?: number;
  interval?: number;
};

export function rateLimit(options?: RateLimitOptions) {
  const tokenCache = new LRUCache({
    max: options?.uniqueTokenPerInterval || 500,
    ttl: options?.interval || 60000
  });

  return {
    check: (limit: number, token: string) =>
      new Promise<void>((resolve, reject) => {
        const tokenCount = (tokenCache.get(token) as number[]) || [0];
        
        if (tokenCount[0] === 0) {
          tokenCache.set(token, tokenCount);
        }
        
        tokenCount[0] += 1;

        const currentUsage = tokenCount[0];
        const isRateLimited = currentUsage >= limit;

        return isRateLimited ? reject() : resolve();
      })
  };
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
const limiter = rateLimit({
  interval: 60 * 1000, // 1 –º–∏–Ω—É—Ç–∞
  uniqueTokenPerInterval: 500
});

export async function POST(request: NextRequest) {
  const ip = request.ip || 'unknown';
  
  try {
    await limiter.check(10, ip); // 10 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É
  } catch {
    return NextResponse.json(
      { error: 'Too many requests' },
      { status: 429 }
    );
  }
  
  // –û–±—Ä–∞–±–æ—Ç–∞–π –∑–∞–ø—Ä–æ—Å
}
```

## üìù Sensitive Data

### –ù–ò–ö–û–ì–î–ê –Ω–µ –ª–æ–≥–∏—Ä—É–π:

```typescript
// ‚ùå –ù–ï–¢!
console.log('User password:', user.password);
console.log('API Key:', process.env.KYCAID_API_KEY);
console.log('Card details:', cardNumber);

// ‚úÖ –î–ê! (masked)
console.log('Processing order for user:', userId);
console.log('Using API (masked):', apiKey.slice(0, 4) + '****');
```

### –ù–ò–ö–û–ì–î–ê –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–π:

```typescript
// ‚ùå –ù–ï–¢!
return NextResponse.json({
  user: {
    id: user.id,
    email: user.email,
    password: user.password, // ‚ùå
    kycDocuments: user.kycDocuments // ‚ùå (–º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ø–∞—Å–ø–æ—Ä—Ç–∞)
  }
});

// ‚úÖ –î–ê!
return NextResponse.json({
  user: {
    id: user.id,
    email: user.email,
    kycStatus: user.kycSession?.status
  }
});
```

### Filtering sensitive fields

```typescript
// ‚úÖ Helper —Ñ—É–Ω–∫—Ü–∏—è
function sanitizeUser(user: User) {
  const { password, ...safeUser } = user;
  return safeUser;
}

// ‚úÖ –ò–ª–∏ —á–µ—Ä–µ–∑ Prisma select
const user = await prisma.user.findUnique({
  where: { id },
  select: {
    id: true,
    email: true,
    role: true,
    profile: true
    // –ù–ï –≤–∫–ª—é—á–∞–π password
  }
});
```

## üõ°Ô∏è CORS & CSP

### CORS Headers (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)

```typescript
// src/app/api/public/route.ts

export async function GET(request: NextRequest) {
  const response = NextResponse.json({ data: 'public' });
  
  // ‚úÖ –û–≥—Ä–∞–Ω–∏—á—å allowed origins
  const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];
  const origin = request.headers.get('origin');
  
  if (origin && allowedOrigins.includes(origin)) {
    response.headers.set('Access-Control-Allow-Origin', origin);
  }
  
  return response;
}
```

### Content Security Policy

```typescript
// next.config.js

const securityHeaders = [
  {
    key: 'X-DNS-Prefetch-Control',
    value: 'on'
  },
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload'
  },
  {
    key: 'X-Frame-Options',
    value: 'SAMEORIGIN'
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block'
  },
  {
    key: 'Referrer-Policy',
    value: 'origin-when-cross-origin'
  }
];

module.exports = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: securityHeaders
      }
    ];
  }
};
```

## üö® Error Handling

### –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫

```typescript
// ‚úÖ –í development - –ø–æ–¥—Ä–æ–±–Ω–æ
if (process.env.NODE_ENV === 'development') {
  console.error('Full error:', error);
  return NextResponse.json(
    { 
      error: error.message,
      stack: error.stack
    },
    { status: 500 }
  );
}

// ‚úÖ –í production - –º–∏–Ω–∏–º–∞–ª—å–Ω–æ
console.error('Error occurred:', {
  message: error.message,
  code: error.code,
  timestamp: new Date().toISOString()
});

return NextResponse.json(
  { error: 'Internal server error' },
  { status: 500 }
);
```

## üìã Security Checklist

### –ü–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º –ø—Ä–æ–≤–µ—Ä—å:

- [ ] –í—Å–µ —Å–µ–∫—Ä–µ—Ç—ã –≤ .env (–Ω–µ –≤ –∫–æ–¥–µ)
- [ ] .env* –¥–æ–±–∞–≤–ª–µ–Ω –≤ .gitignore
- [ ] –ü–∞—Ä–æ–ª–∏ —Ö–µ—à–∏—Ä—É—é—Ç—Å—è –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º
- [ ] –í—Å–µ API routes –∑–∞—â–∏—â–µ–Ω—ã –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
- [ ] –í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–∏—Ä—É—é—Ç—Å—è (Zod)
- [ ] Webhook –ø–æ–¥–ø–∏—Å–∏ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è
- [ ] Sensitive –¥–∞–Ω–Ω—ã–µ –Ω–µ –ª–æ–≥–∏—Ä—É—é—Ç—Å—è
- [ ] Sensitive –¥–∞–Ω–Ω—ã–µ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –∫–ª–∏–µ–Ω—Ç—É
- [ ] HTTPS –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≤—Å–µ—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
- [ ] Security headers –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã
- [ ] Rate limiting –≤–∫–ª—é—á–µ–Ω (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
- [ ] SQL injection –∑–∞—â–∏—Ç–∞ (Prisma)
- [ ] XSS –∑–∞—â–∏—Ç–∞ (React –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
- [ ] CSRF –∑–∞—â–∏—Ç–∞ (NextAuth –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)

---

**–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å - –Ω–µ –æ–ø—Ü–∏—è, –∞ –æ–±—è–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ. –û–¥–∏–Ω –±–∞–≥ –º–æ–∂–µ—Ç —Å—Ç–æ–∏—Ç—å –¥–æ–≤–µ—Ä–∏—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.**
