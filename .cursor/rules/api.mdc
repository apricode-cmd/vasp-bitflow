---
description: "API Routes —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å"
globs: ["src/app/api/**/*.ts", "src/app/api/**/route.ts"]
---

# API Routes Standards - Apricode Exchange

## üõ£Ô∏è –°—Ç—Ä—É–∫—Ç—É—Ä–∞ API Route

### Next.js 14 App Router —Ñ–æ—Ä–º–∞—Ç

```typescript
// src/app/api/orders/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

/**
 * GET /api/orders - –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–∫–∞–∑–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export async function GET(request: NextRequest) {
  try {
    // 1. –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. Query –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status');

    // 3. –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
    const orders = await prisma.order.findMany({
      where: {
        userId: session.user.id,
        ...(status && { status })
      },
      orderBy: { createdAt: 'desc' }
    });

    // 4. –£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
    return NextResponse.json({ orders });
    
  } catch (error) {
    // 5. –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
    console.error('GET /api/orders failed:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/orders - –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑
 */
export async function POST(request: NextRequest) {
  try {
    // 1. –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    const body = await request.json();
    
    const orderSchema = z.object({
      currency: z.enum(['BTC', 'ETH', 'USDT', 'SOL']),
      amount: z.number().positive(),
      walletAddress: z.string().min(26).max(62),
      fiatCurrency: z.enum(['EUR', 'PLN'])
    });

    const validatedData = orderSchema.parse(body);

    // 3. –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { kycSession: true }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ KYC —Å—Ç–∞—Ç—É—Å–∞
    if (user.kycSession?.status !== 'APPROVED') {
      return NextResponse.json(
        { error: 'KYC verification required' },
        { status: 403 }
      );
    }

    // 4. –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–∫–∞–∑–∞
    const order = await prisma.order.create({
      data: {
        userId: user.id,
        currency: validatedData.currency,
        amount: validatedData.amount,
        walletAddress: validatedData.walletAddress,
        fiatCurrency: validatedData.fiatCurrency,
        status: 'PENDING',
        // ... –¥—Ä—É–≥–∏–µ –ø–æ–ª—è
      }
    });

    // 5. –£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç
    return NextResponse.json(
      { order },
      { status: 201 }
    );
    
  } catch (error) {
    // Zod validation errors
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation error', details: error.errors },
        { status: 400 }
      );
    }

    console.error('POST /api/orders failed:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

## üîê –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ (–≤—Å–µ–≥–¥–∞ –ø–µ—Ä–≤—ã–º —à–∞–≥–æ–º)

```typescript
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// ‚úÖ –î–ª—è –≤—Å–µ—Ö –∑–∞—â–∏—â—ë–Ω–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
const session = await getServerSession(authOptions);
if (!session?.user) {
  return NextResponse.json(
    { error: 'Unauthorized' },
    { status: 401 }
  );
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ (Role-based)

```typescript
// ‚úÖ Admin-only —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
const session = await getServerSession(authOptions);
if (session?.user?.role !== 'ADMIN') {
  return NextResponse.json(
    { error: 'Forbidden - Admin access required' },
    { status: 403 }
  );
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–º

```typescript
// ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω—è—Ç—å —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ
const order = await prisma.order.findUnique({
  where: { id: orderId }
});

if (order.userId !== session.user.id && session.user.role !== 'ADMIN') {
  return NextResponse.json(
    { error: 'Forbidden - Not your resource' },
    { status: 403 }
  );
}
```

## ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

### –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π Zod schemas

```typescript
import { z } from 'zod';

// ‚úÖ –û–ø—Ä–µ–¥–µ–ª–∏ —Å—Ö–µ–º—É
const createOrderSchema = z.object({
  currency: z.enum(['BTC', 'ETH', 'USDT', 'SOL'], {
    errorMap: () => ({ message: 'Invalid currency' })
  }),
  amount: z.number().positive('Amount must be positive'),
  walletAddress: z.string()
    .min(26, 'Wallet address too short')
    .max(62, 'Wallet address too long')
    .regex(/^[a-zA-Z0-9]+$/, 'Invalid wallet address format'),
  fiatCurrency: z.enum(['EUR', 'PLN'])
});

// ‚úÖ –í–∞–ª–∏–¥–∏—Ä—É–π –¥–∞–Ω–Ω—ã–µ
try {
  const validatedData = createOrderSchema.parse(body);
  // –ò—Å–ø–æ–ª—å–∑—É–π validatedData
} catch (error) {
  if (error instanceof z.ZodError) {
    return NextResponse.json(
      { 
        error: 'Validation failed', 
        details: error.errors.map(e => ({
          field: e.path.join('.'),
          message: e.message
        }))
      },
      { status: 400 }
    );
  }
}
```

### –°–ª–æ–∂–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —Å —Ä–µ—Ñ–∞–π–Ω–º–µ–Ω—Ç–æ–º

```typescript
const orderSchema = z.object({
  amount: z.number().positive(),
  currency: z.enum(['BTC', 'ETH', 'USDT', 'SOL'])
}).refine(
  (data) => {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å—É–º–º—ã –¥–ª—è –∫–∞–∂–¥–æ–π –≤–∞–ª—é—Ç—ã
    const minAmounts = { BTC: 50, ETH: 50, USDT: 20, SOL: 20 };
    return data.amount >= minAmounts[data.currency];
  },
  {
    message: 'Amount is below minimum for selected currency',
    path: ['amount']
  }
);
```

## üì§ HTTP Response Patterns

### –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —Å—Ç–∞—Ç—É—Å –∫–æ–¥—ã

```typescript
// ‚úÖ 200 OK - –£—Å–ø–µ—à–Ω—ã–π GET/PATCH
return NextResponse.json({ data });

// ‚úÖ 201 Created - –£—Å–ø–µ—à–Ω—ã–π POST (—Å–æ–∑–¥–∞–Ω–∏–µ)
return NextResponse.json({ order }, { status: 201 });

// ‚úÖ 204 No Content - –£—Å–ø–µ—à–Ω—ã–π DELETE (–±–µ–∑ —Ç–µ–ª–∞)
return new NextResponse(null, { status: 204 });

// ‚úÖ 400 Bad Request - –ù–µ–≤–∞–ª–∏–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
return NextResponse.json(
  { error: 'Invalid input', details: validationErrors },
  { status: 400 }
);

// ‚úÖ 401 Unauthorized - –ù–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω
return NextResponse.json(
  { error: 'Unauthorized' },
  { status: 401 }
);

// ‚úÖ 403 Forbidden - –ù–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
return NextResponse.json(
  { error: 'Forbidden' },
  { status: 403 }
);

// ‚úÖ 404 Not Found - –†–µ—Å—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω
return NextResponse.json(
  { error: 'Order not found' },
  { status: 404 }
);

// ‚úÖ 500 Internal Server Error - –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞
return NextResponse.json(
  { error: 'Internal server error' },
  { status: 500 }
);
```

### –ö–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—à–∏–±–æ–∫

```typescript
// ‚úÖ –í—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–π –æ—à–∏–±–∫–∏ –≤ –æ–¥–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
interface ErrorResponse {
  error: string;           // –ö—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ
  message?: string;        // –î–µ—Ç–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
  details?: unknown;       // –î–æ–ø. –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
  code?: string;           // –ö–æ–¥ –æ—à–∏–±–∫–∏ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
}

return NextResponse.json(
  {
    error: 'Validation failed',
    message: 'Invalid wallet address format',
    code: 'INVALID_WALLET_ADDRESS'
  },
  { status: 400 }
);
```

## üîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

### Try-catch –ø–∞—Ç—Ç–µ—Ä–Ω (–≤—Å–µ–≥–¥–∞)

```typescript
export async function POST(request: NextRequest) {
  try {
    // –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞
    
  } catch (error) {
    // –õ–æ–≥–∏—Ä—É–π —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
    console.error('POST /api/orders failed:', {
      error,
      url: request.url,
      method: request.method
    });
    
    // –°–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation error', details: error.errors },
        { status: 400 }
      );
    }
    
    if (error.code === 'P2002') { // Prisma unique constraint
      return NextResponse.json(
        { error: 'Resource already exists' },
        { status: 409 }
      );
    }
    
    // –û–±—â–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

## üéØ Dynamic Routes

### –ü–∞—Ä–∞–º–µ—Ç—Ä—ã URL

```typescript
// src/app/api/orders/[id]/route.ts

interface RouteParams {
  params: {
    id: string;
  };
}

export async function GET(
  request: NextRequest,
  { params }: RouteParams
) {
  const orderId = params.id;
  
  // –í–∞–ª–∏–¥–∞—Ü–∏—è ID
  if (!orderId || typeof orderId !== 'string') {
    return NextResponse.json(
      { error: 'Invalid order ID' },
      { status: 400 }
    );
  }
  
  // ... –æ—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞
}
```

## üîó –í–Ω–µ—à–Ω–∏–µ API –≤—ã–∑–æ–≤—ã

### –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è KYCAID

```typescript
// src/lib/kycaid.ts

interface CreateKycSessionParams {
  userId: string;
  email: string;
}

export async function createKycSession({ 
  userId, 
  email 
}: CreateKycSessionParams) {
  try {
    const response = await fetch('https://api.kycaid.com/v1/sessions', {
      method: 'POST',
      headers: {
        'Authorization': `Token ${process.env.KYCAID_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        form_id: process.env.KYCAID_FORM_ID,
        external_applicant_id: userId,
        email
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`KYCAID API error: ${error.message}`);
    }

    return await response.json();
    
  } catch (error) {
    console.error('KYCAID session creation failed:', error);
    throw error;
  }
}
```

### –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è CoinGecko

```typescript
// src/lib/coingecko.ts

export async function getExchangeRate(
  cryptoCurrency: string,
  fiatCurrency: string
): Promise<number> {
  try {
    const coinIds = {
      BTC: 'bitcoin',
      ETH: 'ethereum',
      USDT: 'tether',
      SOL: 'solana'
    };

    const response = await fetch(
      `https://api.coingecko.com/api/v3/simple/price?ids=${coinIds[cryptoCurrency]}&vs_currencies=${fiatCurrency.toLowerCase()}`,
      {
        next: { revalidate: 60 } // –ö–µ—à –Ω–∞ 60 —Å–µ–∫—É–Ω–¥
      }
    );

    if (!response.ok) {
      throw new Error('Failed to fetch exchange rate');
    }

    const data = await response.json();
    return data[coinIds[cryptoCurrency]][fiatCurrency.toLowerCase()];
    
  } catch (error) {
    console.error('CoinGecko API error:', error);
    throw new Error('Failed to fetch exchange rate');
  }
}
```

## ü™ù Webhooks

### –û–±—Ä–∞–±–æ—Ç–∫–∞ KYCAID webhook

```typescript
// src/app/api/kyc/webhook/route.ts

import crypto from 'crypto';

export async function POST(request: NextRequest) {
  try {
    // 1. –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–∏
    const signature = request.headers.get('x-signature');
    const body = await request.text();
    
    const expectedSignature = crypto
      .createHmac('sha256', process.env.KYCAID_WEBHOOK_SECRET!)
      .update(body)
      .digest('hex');

    if (signature !== expectedSignature) {
      return NextResponse.json(
        { error: 'Invalid signature' },
        { status: 401 }
      );
    }

    // 2. –ü–∞—Ä—Å–∏–Ω–≥ –¥–∞–Ω–Ω—ã—Ö
    const webhookData = JSON.parse(body);
    const { applicant_id, verification_id, status } = webhookData;

    // 3. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ KYC —Å—Ç–∞—Ç—É—Å–∞
    await prisma.kycSession.update({
      where: { 
        userId: applicant_id 
      },
      data: {
        status: status === 'completed' ? 'APPROVED' : 'REJECTED',
        verificationId: verification_id,
        completedAt: new Date()
      }
    });

    // 4. –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è
    await prisma.auditLog.create({
      data: {
        action: 'KYC_WEBHOOK_RECEIVED',
        details: { status, applicant_id }
      }
    });

    return NextResponse.json({ success: true });
    
  } catch (error) {
    console.error('KYC webhook error:', error);
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 500 }
    );
  }
}
```

## üìä Query Parameters

### –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∏ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏

```typescript
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  
  // ‚úÖ Pagination
  const page = parseInt(searchParams.get('page') || '1');
  const limit = parseInt(searchParams.get('limit') || '10');
  const skip = (page - 1) * limit;
  
  // ‚úÖ Filters
  const status = searchParams.get('status'); // ?status=PENDING
  const currency = searchParams.get('currency'); // ?currency=BTC
  
  // ‚úÖ Sorting
  const sortBy = searchParams.get('sortBy') || 'createdAt';
  const sortOrder = searchParams.get('sortOrder') || 'desc';
  
  const orders = await prisma.order.findMany({
    where: {
      ...(status && { status }),
      ...(currency && { currency })
    },
    orderBy: {
      [sortBy]: sortOrder
    },
    skip,
    take: limit
  });
  
  // –í–µ—Ä–Ω—É—Ç—å —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
  const total = await prisma.order.count({ where: { /* same filters */ } });
  
  return NextResponse.json({
    data: orders,
    meta: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  });
}
```

## üõ°Ô∏è Security Best Practices

### 1. Rate Limiting (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –Ω–æ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)

```typescript
// –ò—Å–ø–æ–ª—å–∑—É–π Vercel Edge Config –∏–ª–∏ Redis –¥–ª—è rate limiting
import { ratelimit } from '@/lib/ratelimit';

export async function POST(request: NextRequest) {
  const ip = request.ip || 'unknown';
  
  const { success } = await ratelimit.limit(ip);
  
  if (!success) {
    return NextResponse.json(
      { error: 'Too many requests' },
      { status: 429 }
    );
  }
  
  // ... –æ—Å—Ç–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞
}
```

### 2. CORS Headers (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)

```typescript
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': process.env.ALLOWED_ORIGIN || '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    }
  });
}
```

### 3. Sensitive Data

```typescript
// ‚ùå –ù–ï –≤–æ–∑–≤—Ä–∞—â–∞–π —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
return NextResponse.json({
  user: {
    id: user.id,
    email: user.email,
    password: user.password, // ‚ùå –ù–ò–ö–û–ì–î–ê!
    kycDocuments: user.kycDocuments // ‚ùå –ë—É–¥—å –æ—Å—Ç–æ—Ä–æ–∂–µ–Ω
  }
});

// ‚úÖ –§–∏–ª—å—Ç—Ä—É–π –¥–∞–Ω–Ω—ã–µ
const { password, ...safeUser } = user;
return NextResponse.json({ user: safeUser });

// ‚úÖ –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π select –≤ Prisma
const user = await prisma.user.findUnique({
  where: { id },
  select: {
    id: true,
    email: true,
    role: true,
    // –ù–ï –≤–∫–ª—é—á–∞–π password
  }
});
```

## üö´ –ê–Ω—Ç–∏–ø–∞—Ç—Ç–µ—Ä–Ω—ã (–ù–ï –¥–µ–ª–∞–π —Ç–∞–∫)

```typescript
// ‚ùå –ù–µ—Ç –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
export async function POST(request: NextRequest) {
  const body = await request.json();
  await prisma.order.create({ data: body });
}

// ‚ùå –ù–µ—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏
export async function POST(request: NextRequest) {
  const body = await request.json();
  // –ü—Ä—è–º–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏
  await doSomething(body.amount);
}

// ‚ùå –ù–µ –ª–æ–≥–∏—Ä—É–π –æ—à–∏–±–∫–∏
catch (error) {
  return NextResponse.json({ error: 'Error' }, { status: 500 });
}

// ‚ùå –†–∞—Å–∫—Ä—ã—Ç–∏–µ –¥–µ—Ç–∞–ª–µ–π –æ—à–∏–±–æ–∫ –∫–ª–∏–µ–Ω—Ç—É
catch (error) {
  return NextResponse.json({ error: error.message }, { status: 500 });
}

// ‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ any
export async function POST(request: any) { ... }
```

---

**–ü–æ–º–Ω–∏:** –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å > –£–¥–æ–±—Å—Ç–≤–æ. –ö–∞–∂–¥—ã–π API endpoint - –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –∞—Ç–∞–∫–∏.
