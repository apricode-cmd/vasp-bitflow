---
description: "Testing —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã –∏ TDD –ø–æ–¥—Ö–æ–¥"
globs: ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "__tests__/**/*"]
---

# Testing Standards - Apricode Exchange

## üß™ –§–∏–ª–æ—Å–æ—Ñ–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

### Test-Driven Development (TDD)

```
1. –ù–∞–ø–∏—à–∏ —Ç–µ—Å—Ç (RED) ‚ùå
2. –ù–∞–ø–∏—à–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∫–æ–¥ –¥–ª—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è (GREEN) ‚úÖ
3. –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏ –∫–æ–¥ (REFACTOR) ‚ôªÔ∏è
4. –ü–æ–≤—Ç–æ—Ä–∏
```

### –ß—Ç–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å?

**‚úÖ –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Ç–µ—Å—Ç–∏—Ä—É–π:**
- –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞
- API endpoints
- –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
- Auth & Authorization
- Edge cases –∏ –≥—Ä–∞–Ω–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
- Error handling

**‚ö†Ô∏è –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ:**
- UI –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã (–ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
- –£—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

**‚ùå –ù–ï —Ç–µ—Å—Ç–∏—Ä—É–π:**
- Third-party –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
- –¢—Ä–∏–≤–∏–∞–ª—å–Ω—ã–π –∫–æ–¥ (–≥–µ—Ç—Ç–µ—Ä—ã/—Å–µ—Ç—Ç–µ—Ä—ã)
- –ö–æ–¥ –±–µ–∑ –ª–æ–≥–∏–∫–∏

## üì¶ Testing Stack

```json
{
  "devDependencies": {
    "vitest": "^1.0.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "^14.5.0",
    "@testing-library/jest-dom": "^6.1.0",
    "msw": "^2.0.0"
  }
}
```

## üéØ Unit Tests

### API Route Tests

```typescript
// __tests__/api/orders.test.ts

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { POST } from '@/app/api/orders/route';
import { NextRequest } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';

// Mock –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
vi.mock('next-auth');
vi.mock('@/lib/prisma');

describe('POST /api/orders', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should create order when user is authenticated and KYC approved', async () => {
    // Arrange - –ø–æ–¥–≥–æ—Ç–æ–≤—å –¥–∞–Ω–Ω—ã–µ
    const mockSession = {
      user: { 
        id: 'user123', 
        email: 'test@test.com',
        role: 'CLIENT' 
      }
    };
    
    const mockUser = {
      id: 'user123',
      email: 'test@test.com',
      kycSession: { status: 'APPROVED' }
    };
    
    const mockOrder = {
      id: 'order123',
      userId: 'user123',
      currency: 'BTC',
      amount: 1000,
      status: 'PENDING'
    };

    vi.mocked(getServerSession).mockResolvedValue(mockSession);
    vi.mocked(prisma.user.findUnique).mockResolvedValue(mockUser);
    vi.mocked(prisma.order.create).mockResolvedValue(mockOrder);

    const request = new NextRequest('http://localhost:3000/api/orders', {
      method: 'POST',
      body: JSON.stringify({
        currency: 'BTC',
        amount: 1000,
        walletAddress: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',
        fiatCurrency: 'EUR'
      })
    });

    // Act - –≤—ã–ø–æ–ª–Ω–∏ –¥–µ–π—Å—Ç–≤–∏–µ
    const response = await POST(request);
    const data = await response.json();

    // Assert - –ø—Ä–æ–≤–µ—Ä—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    expect(response.status).toBe(201);
    expect(data.order).toEqual(mockOrder);
    expect(prisma.order.create).toHaveBeenCalledWith({
      data: expect.objectContaining({
        userId: 'user123',
        currency: 'BTC',
        amount: 1000
      })
    });
  });

  it('should return 401 when user not authenticated', async () => {
    vi.mocked(getServerSession).mockResolvedValue(null);

    const request = new NextRequest('http://localhost:3000/api/orders', {
      method: 'POST',
      body: JSON.stringify({
        currency: 'BTC',
        amount: 1000,
        walletAddress: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',
        fiatCurrency: 'EUR'
      })
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(401);
    expect(data.error).toBe('Unauthorized');
  });

  it('should return 403 when KYC not approved', async () => {
    const mockSession = {
      user: { id: 'user123', role: 'CLIENT' }
    };
    
    const mockUser = {
      id: 'user123',
      kycSession: { status: 'PENDING' }
    };

    vi.mocked(getServerSession).mockResolvedValue(mockSession);
    vi.mocked(prisma.user.findUnique).mockResolvedValue(mockUser);

    const request = new NextRequest('http://localhost:3000/api/orders', {
      method: 'POST',
      body: JSON.stringify({
        currency: 'BTC',
        amount: 1000,
        walletAddress: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',
        fiatCurrency: 'EUR'
      })
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(403);
    expect(data.error).toBe('KYC verification required');
  });

  it('should return 400 on validation error', async () => {
    const mockSession = {
      user: { id: 'user123', role: 'CLIENT' }
    };

    vi.mocked(getServerSession).mockResolvedValue(mockSession);

    const request = new NextRequest('http://localhost:3000/api/orders', {
      method: 'POST',
      body: JSON.stringify({
        currency: 'INVALID',
        amount: -100, // –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ
        walletAddress: 'short',
        fiatCurrency: 'USD'
      })
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toBe('Validation error');
    expect(data.details).toBeDefined();
  });
});
```

### Utility Function Tests

```typescript
// __tests__/lib/utils.test.ts

import { describe, it, expect } from 'vitest';
import { calculateOrderTotal, formatCurrency } from '@/lib/utils';

describe('calculateOrderTotal', () => {
  it('should calculate total with 1.5% fee', () => {
    const amount = 1000;
    const rate = 50000;
    const fee = 0.015;

    const total = calculateOrderTotal(amount, rate, fee);

    expect(total).toBe(50750); // 1000 * 50000 * 1.015
  });

  it('should handle zero amount', () => {
    const total = calculateOrderTotal(0, 50000, 0.015);
    expect(total).toBe(0);
  });

  it('should handle zero rate', () => {
    const total = calculateOrderTotal(1000, 0, 0.015);
    expect(total).toBe(0);
  });

  it('should handle no fee', () => {
    const total = calculateOrderTotal(1000, 50000, 0);
    expect(total).toBe(50000);
  });
});

describe('formatCurrency', () => {
  it('should format EUR correctly', () => {
    const formatted = formatCurrency(1234.56, 'EUR');
    expect(formatted).toBe('‚Ç¨1,234.56');
  });

  it('should format PLN correctly', () => {
    const formatted = formatCurrency(1234.56, 'PLN');
    expect(formatted).toBe('1 234,56 z≈Ç');
  });

  it('should handle zero', () => {
    const formatted = formatCurrency(0, 'EUR');
    expect(formatted).toBe('‚Ç¨0.00');
  });

  it('should handle large numbers', () => {
    const formatted = formatCurrency(1000000, 'EUR');
    expect(formatted).toBe('‚Ç¨1,000,000.00');
  });
});
```

## üß© Integration Tests

### Database Tests

```typescript
// __tests__/integration/orders.test.ts

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { prisma } from '@/lib/prisma';
import { createOrder } from '@/lib/orders';

describe('Order Creation Integration', () => {
  let testUser;

  beforeEach(async () => {
    // –°–æ–∑–¥–∞–π —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    testUser = await prisma.user.create({
      data: {
        email: 'test@test.com',
        password: 'hashedpassword',
        role: 'CLIENT',
        kycSession: {
          create: {
            status: 'APPROVED'
          }
        }
      }
    });
  });

  afterEach(async () => {
    // –û—á–∏—Å—Ç–∏ —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    await prisma.order.deleteMany();
    await prisma.kycSession.deleteMany();
    await prisma.user.deleteMany();
  });

  it('should create order in database', async () => {
    const orderData = {
      userId: testUser.id,
      currency: 'BTC',
      amount: 1000,
      walletAddress: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',
      fiatCurrency: 'EUR',
      rate: 50000
    };

    const order = await createOrder(orderData);

    expect(order.id).toBeDefined();
    expect(order.userId).toBe(testUser.id);
    expect(order.status).toBe('PENDING');

    // –ü—Ä–æ–≤–µ—Ä—å, —á—Ç–æ order —Å–æ–∑–¥–∞–Ω –≤ –ë–î
    const dbOrder = await prisma.order.findUnique({
      where: { id: order.id }
    });

    expect(dbOrder).not.toBeNull();
    expect(dbOrder.amount).toBe(1000);
  });

  it('should fail when KYC not approved', async () => {
    // –û–±–Ω–æ–≤–∏ KYC —Å—Ç–∞—Ç—É—Å
    await prisma.kycSession.update({
      where: { userId: testUser.id },
      data: { status: 'PENDING' }
    });

    const orderData = {
      userId: testUser.id,
      currency: 'BTC',
      amount: 1000,
      walletAddress: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',
      fiatCurrency: 'EUR',
      rate: 50000
    };

    await expect(createOrder(orderData)).rejects.toThrow('KYC not approved');
  });
});
```

## üé≠ Component Tests (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

```typescript
// __tests__/components/OrderCard.test.tsx

import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { OrderCard } from '@/components/OrderCard';

describe('OrderCard', () => {
  it('should render order details', () => {
    const order = {
      id: 'order123',
      currency: 'BTC',
      amount: 1000,
      status: 'PENDING',
      createdAt: new Date('2025-01-01')
    };

    render(<OrderCard order={order} />);

    expect(screen.getByText('BTC')).toBeInTheDocument();
    expect(screen.getByText('‚Ç¨1,000.00')).toBeInTheDocument();
    expect(screen.getByText('Pending')).toBeInTheDocument();
  });

  it('should call onCancel when cancel button clicked', () => {
    const onCancel = vi.fn();
    const order = {
      id: 'order123',
      currency: 'BTC',
      amount: 1000,
      status: 'PENDING',
      createdAt: new Date()
    };

    render(<OrderCard order={order} onCancel={onCancel} />);

    const cancelButton = screen.getByRole('button', { name: /cancel/i });
    fireEvent.click(cancelButton);

    expect(onCancel).toHaveBeenCalledWith('order123');
  });

  it('should not show cancel button for completed orders', () => {
    const order = {
      id: 'order123',
      currency: 'BTC',
      amount: 1000,
      status: 'COMPLETED',
      createdAt: new Date()
    };

    render(<OrderCard order={order} />);

    const cancelButton = screen.queryByRole('button', { name: /cancel/i });
    expect(cancelButton).not.toBeInTheDocument();
  });
});
```

## üåê E2E Tests (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, Playwright)

```typescript
// e2e/order-flow.spec.ts

import { test, expect } from '@playwright/test';

test.describe('Order Flow', () => {
  test.beforeEach(async ({ page }) => {
    // –õ–æ–≥–∏–Ω
    await page.goto('/login');
    await page.fill('input[name="email"]', 'test@test.com');
    await page.fill('input[name="password"]', 'Test123!');
    await page.click('button[type="submit"]');
    await page.waitForURL('/dashboard');
  });

  test('should complete full order flow', async ({ page }) => {
    // Navigate to buy page
    await page.click('text=Buy Crypto');
    await page.waitForURL('/buy');

    // Fill form
    await page.selectOption('select[name="currency"]', 'BTC');
    await page.fill('input[name="amount"]', '1000');
    await page.fill('input[name="walletAddress"]', 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh');
    
    // Submit
    await page.click('button[type="submit"]');
    
    // Wait for order created
    await page.waitForURL('/orders/*');
    
    // Verify order details
    await expect(page.locator('text=Order Created')).toBeVisible();
    await expect(page.locator('text=BTC')).toBeVisible();
    await expect(page.locator('text=‚Ç¨1,000')).toBeVisible();
  });
});
```

## üé™ Mocking

### Mock External APIs

```typescript
// __tests__/lib/coingecko.test.ts

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { getExchangeRate } from '@/lib/coingecko';

// Mock fetch
global.fetch = vi.fn();

describe('CoinGecko API', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should fetch BTC to EUR rate', async () => {
    const mockResponse = {
      bitcoin: {
        eur: 50000
      }
    };

    vi.mocked(fetch).mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse
    } as Response);

    const rate = await getExchangeRate('BTC', 'EUR');

    expect(rate).toBe(50000);
    expect(fetch).toHaveBeenCalledWith(
      expect.stringContaining('bitcoin'),
      expect.any(Object)
    );
  });

  it('should throw error on API failure', async () => {
    vi.mocked(fetch).mockResolvedValueOnce({
      ok: false,
      status: 500
    } as Response);

    await expect(getExchangeRate('BTC', 'EUR')).rejects.toThrow();
  });
});
```

### Mock Prisma

```typescript
// __tests__/__mocks__/prisma.ts

import { vi } from 'vitest';
import { PrismaClient } from '@prisma/client';

export const prismaMock = {
  user: {
    create: vi.fn(),
    findUnique: vi.fn(),
    findMany: vi.fn(),
    update: vi.fn(),
    delete: vi.fn()
  },
  order: {
    create: vi.fn(),
    findUnique: vi.fn(),
    findMany: vi.fn(),
    update: vi.fn(),
    delete: vi.fn()
  }
};

vi.mock('@/lib/prisma', () => ({
  prisma: prismaMock
}));
```

## üìä Test Coverage

### Vitest Config

```typescript
// vitest.config.ts

import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        '.next/',
        'coverage/',
        '**/*.config.*',
        '**/types/**'
      ],
      // ‚úÖ –¶–µ–ª–µ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–∫—Ä—ã—Ç–∏—è
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 75,
        statements: 80
      }
    },
    setupFiles: ['./vitest.setup.ts']
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
});
```

### Setup File

```typescript
// vitest.setup.ts

import '@testing-library/jest-dom';
import { beforeAll, afterEach, afterAll } from 'vitest';
import { cleanup } from '@testing-library/react';

// Cleanup –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ç–µ—Å—Ç–∞
afterEach(() => {
  cleanup();
});

// Mock environment variables
beforeAll(() => {
  process.env.DATABASE_URL = 'postgresql://test:test@localhost:5432/test';
  process.env.NEXTAUTH_SECRET = 'test-secret';
  process.env.NEXTAUTH_URL = 'http://localhost:3000';
});
```

## üèÉ‚Äç‚ôÇÔ∏è Running Tests

```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:watch": "vitest --watch",
    "e2e": "playwright test",
    "e2e:ui": "playwright test --ui"
  }
}
```

## ‚úÖ Testing Best Practices

### 1. Arrange-Act-Assert Pattern

```typescript
it('should do something', () => {
  // Arrange - –ø–æ–¥–≥–æ—Ç–æ–≤—å –¥–∞–Ω–Ω—ã–µ –∏ –º–æ–∫–∏
  const input = 'test';
  const expected = 'TEST';
  
  // Act - –≤—ã–ø–æ–ª–Ω–∏ –¥–µ–π—Å—Ç–≤–∏–µ
  const result = toUpperCase(input);
  
  // Assert - –ø—Ä–æ–≤–µ—Ä—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
  expect(result).toBe(expected);
});
```

### 2. –û–ø–∏—Å–∞—Ç–µ–ª—å–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤

```typescript
// ‚ùå –ü–ª–æ—Ö–æ
it('works', () => { ... });
it('test 1', () => { ... });

// ‚úÖ –•–æ—Ä–æ—à–æ
it('should return uppercase string', () => { ... });
it('should throw error when input is null', () => { ... });
it('should create order when user is authenticated and KYC approved', () => { ... });
```

### 3. –¢–µ—Å—Ç–∏—Ä—É–π edge cases

```typescript
describe('calculateTotal', () => {
  it('should handle normal values', () => { ... });
  it('should handle zero amount', () => { ... });
  it('should handle negative numbers', () => { ... });
  it('should handle very large numbers', () => { ... });
  it('should handle decimal precision', () => { ... });
  it('should throw on invalid input', () => { ... });
});
```

### 4. –ò–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã

```typescript
// ‚úÖ –ö–∞–∂–¥—ã–π —Ç–µ—Å—Ç –Ω–µ–∑–∞–≤–∏—Å–∏–º
describe('UserService', () => {
  beforeEach(() => {
    // –û—á–∏—Å—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ç–µ—Å—Ç–æ–º
    vi.clearAllMocks();
  });

  it('test 1', () => { ... });
  it('test 2', () => { ... });
});

// ‚ùå –¢–µ—Å—Ç—ã –∑–∞–≤–∏—Å—è—Ç –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞
let userId;
it('creates user', async () => {
  userId = await createUser();
});
it('updates user', async () => {
  await updateUser(userId); // –ó–∞–≤–∏—Å–∏—Ç –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ!
});
```

### 5. –ù–µ —Ç–µ—Å—Ç–∏—Ä—É–π implementation details

```typescript
// ‚ùå –ü–ª–æ—Ö–æ - —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏
it('should call setState 3 times', () => {
  const component = render(<MyComponent />);
  // ...
  expect(setState).toHaveBeenCalledTimes(3);
});

// ‚úÖ –•–æ—Ä–æ—à–æ - —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ
it('should display error message when form is invalid', () => {
  const { getByText, getByRole } = render(<MyForm />);
  fireEvent.click(getByRole('button'));
  expect(getByText('Email is required')).toBeInTheDocument();
});
```

## üö´ –ê–Ω—Ç–∏–ø–∞—Ç—Ç–µ—Ä–Ω—ã

```typescript
// ‚ùå –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –º–æ–∫–æ–≤
vi.mock('./everything');

// ‚ùå –¢–µ—Å—Ç—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç –ø–æ—Ä—è–¥–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
describe('dependent tests', () => {
  let sharedState;
  it('test 1', () => { sharedState = 'data'; });
  it('test 2', () => { expect(sharedState).toBe('data'); });
});

// ‚ùå –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤
it('should test private method', () => {
  const instance = new MyClass();
  expect(instance._privateMethod()).toBe(true);
});

// ‚ùå –°–ª–∏—à–∫–æ–º –æ–±—â–∏–µ assertions
it('should work', () => {
  const result = doSomething();
  expect(result).toBeTruthy(); // –ß—Ç–æ –∏–º–µ–Ω–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º?
});
```

## üìù Test Checklist

–ü–µ—Ä–µ–¥ –∫–æ–º–º–∏—Ç–æ–º —É–±–µ–¥–∏—Å—å:

- [ ] –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç (`npm test`)
- [ ] –ü–æ–∫—Ä—ã—Ç–∏–µ >= 80% –¥–ª—è –Ω–æ–≤—ã—Ö –º–æ–¥—É–ª–µ–π
- [ ] –¢–µ—Å—Ç—ã –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞
- [ ] Edge cases –ø–æ–∫—Ä—ã—Ç—ã
- [ ] –ú–æ–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã
- [ ] –ù–∞–∑–≤–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤ –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω—ã
- [ ] –ù–µ—Ç flaky tests (–Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω—ã—Ö)

---

**"–ö–æ–¥ –±–µ–∑ —Ç–µ—Å—Ç–æ–≤ - —É–Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ —Å –ø–µ—Ä–≤–æ–≥–æ –¥–Ω—è" - Michael Feathers**
